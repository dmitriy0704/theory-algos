# Бинарный поиск

Бинарный поиск — это алгоритм; на входе он получает отсортированный
список элементов. Если элемент, который вы ищете, присутствует в списке,
то бинарный поиск возвращает ту позицию, в которой он был найден. В противном
случае бинарный поиск возвращает null.

Бинарный поиск — тип поискового алгоритма, который последовательно делит пополам
заранее отсортированный массив данных, чтобы обнаружить нужный элемент. Другие
его названия — двоичный поиск, метод половинного деления, дихотомия.

Принцип работы алгоритма бинарного поиска
Основная последовательность действий алгоритма выглядит так:

1. Сортируем массив данных.
2. Делим его пополам и находим середину.
3. Сравниваем срединный элемент с заданным искомым элементом.
4. Если искомое число больше среднего — продолжаем поиск в правой части
   массива (если он отсортирован по возрастанию): делим ее пополам, повторяя
   пункт 3. Если же заданное число меньше — алгоритм продолжит поиск в левой
   части массива, снова возвращаясь к пункту 3.

![binary-search.png](/img/binary-search.png)

При таком поиске список делится пополам и отбрасывается каждый раз ненужная
часть. В списке из n элементов обычный поиск потребует n шагов, а
бинарный - log2(n).

Бинарный поиск работает только в том случае, если список отсортирован.

## Функция binarySearch()

Функция **`binary_search()`** получает отсортированный массив и значение. Если
значение присутствует в массиве, то функция возвращает его позицию. При
этом мы должны следить за тем, в какой части массива проводится поиск.
Вначале это весь массив:

Поэтапно:

```java
public static void main(String[] args) {
    int[] arrays = {2, 4, 3, 5, 56, 32, 54, 34, 23}; //-> [2, 3, 4, 5, 23, 32, 34, 43, 54, 56, 76]
    int item = 32; //-> Искомое число
    System.out.println(Arrays.toString(arrays));

    Arrays.sort(arrays);
    System.out.println(Arrays.toString(arrays));

    //-> Самое низкое и самое высокое значения массива
    int low = 0;
    int high = arrays.length - 1;

    //-> Дальше алгоритм проверяет средний элемент
    int mid = (low + high) / 2; //-> Если предполагаемое число нечетное - оно округляется в меньшую сторону
    int guess = arrays[mid]; //-> Предполагаемое число

    //-> Если предполагаемое число было слишком мало, то переменная low
    // обновляется соответственно:
    if (guess < item) {
        low = mid + 1;
    }

    //-> А если предполагаемое число было слишком велико, то обновляется переменная high.
    if (guess > item) {
        high = mid - 1;
    }

    // Или
    if (guess == item) {
        return mid; //-> Значение найдено
    }

    return -1; //-> Если не найдено

}

int binarySearch(int[] arrays, int target) {
    //-> В переменных low и high хранятся границы
    // той части списка, в которой выполняется поиск
    int low = 0;
    int high = arrays.length - 1;

    //-> Пока эта часть не сократится до одного элемента...
    while (low <= high) {
        //-> ...проверяем среднее значение
        int mid = (low + high) / 2;
        int guess = arrays[mid];

        if (guess == target) { //-> значение найдено
            return mid;
        }

        if (guess < target) { //-> мало, увеличиваем минимальное на  [среднее+1]
            low = mid + 1;
        }
        if (guess > target) { //-> много, уменьшаем максимальное на [среднее-1]
            high = mid - 1;
        }
    }
    return -1;
}


```
